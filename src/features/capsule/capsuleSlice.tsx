import { Draft, createAsyncThunk, createSlice } from "@reduxjs/toolkit";
import { fetchCapsules } from "./capsuleApi";

interface Capsule {
  capsule_serial: string;
  capsule_id: string;
  status: string;
  original_launch: string;
  original_launch_unix: number;
  missions: {
    name: string;
    flight: number;
  }[];
  landings: number;
  type: string;
  details: string;
  reuse_count: number;
}

interface Action {
  payload: any;
  type: string;
}

enum Order {
  Ascending = "asc",
  Descending = "desc",
}

interface CapsuleKey {
  id: string;
  name: string;
}

const LIMIT: number = 6;

interface CapsuleState {
  capsules: Capsule[];
  paginatedCapsules: Capsule[];
  status: string;
  order: Order;
  hasMore: boolean;
  page: number;
  sort: CapsuleKey;
  searchValue: string;
  capsuleToView?: Capsule;
  searchPropery: CapsuleKey;
}

const initialState: CapsuleState = {
  capsules: [],
  paginatedCapsules: [],
  status: "idle",
  order: Order.Descending,
  page: 1,
  hasMore: true,
  sort: {
    id: "capsule_serial",
    name: "Capsule Serial",
  },
  searchValue: "",
  capsuleToView: undefined,
  searchPropery: {
    id: "capsule_serial",
    name: "Capsule Serial",
  },
};

export const capsulesSlice = createSlice({
  name: "capsules",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setItems: (state: Draft<CapsuleState>, action: Action) => {
      state.capsules = action.payload;
      state.page = 1;
      state.paginatedCapsules = action.payload.slice(0, state.page * LIMIT);
      state.hasMore = state.paginatedCapsules.length < state.capsules.length;
    },
    updateSearchPropery: (state: Draft<CapsuleState>, action: Action) => {
      state.searchPropery = action.payload;
      state.searchValue = "";
    },
    updateSearchValue: (state: Draft<CapsuleState>, action: Action) => {
      state.searchValue = action.payload;
    },
    updateSortProperty: (state: Draft<CapsuleState>, action: Action) => {
      state.sort = action.payload;
    },
    viewCapsule: (state: Draft<CapsuleState>, action: Action) => {
      state.capsuleToView = action.payload;
    },
    dimissCapsuleViewer: (state: Draft<CapsuleState>) => {
      state.capsuleToView = undefined;
    },
    updatePage: (state: Draft<CapsuleState>, action: Action) => {
      const newPage = state.page + 1;
      state.page = newPage;
      state.paginatedCapsules = state.capsules.slice(
        0,
        state.paginatedCapsules.length + 3
      );
      state.hasMore = state.paginatedCapsules.length < state.capsules.length;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(searchItemsAsync.pending, (state) => {
        state.status = "loading";
      })
      .addCase(searchItemsAsync.fulfilled, (state, action) => {
        state.status = "idle";
        state.capsules = action.payload;
        state.paginatedCapsules = action.payload.slice(0, LIMIT);
        state.hasMore = state.paginatedCapsules.length < action.payload.length;
        state.page = 1;
      });
  },
});

export const searchItemsAsync = createAsyncThunk(
  "capsules/searchItems",
  async (state: {
    sort: string;
    order: string;
    searchProperty: string;
    searchValue: string;
  }) => {
    console.log("Searching...");
    let searchValueFormatted = state.searchValue;
    if (state.searchProperty === "original_launch") {
      const dateObject = new Date(state.searchValue);
      const formattedDateString = dateObject.toISOString();
      searchValueFormatted = formattedDateString;
    }
    const response = await fetchCapsules(
      state.sort,
      state.order,
      state.searchProperty,
      searchValueFormatted
    );
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);

export const {
  updatePage,
  viewCapsule,
  dimissCapsuleViewer,
  setItems,
  updateSortProperty,
  updateSearchPropery,
  updateSearchValue,
} = capsulesSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const getCapsules = (state: any) => {
  return state.capsule.capsules;
};

export const getPaginatedCapsules = (state: any) => {
  return state.capsule.paginatedCapsules;
};

export const hasMore = (state: any) => {
  return state.capsule.hasMore;
};
export const getSearchPropery = (state: any) => {
  return state.capsule.searchPropery;
};
export const getSort = (state: any) => {
  return state.capsule.sort;
};
export const getCapsuleToView = (state: any) => {
  return state.capsule.capsuleToView;
};

export const getOrder = (state: any) => {
  return state.capsule.order;
};

export const getStatus = (state: any) => {
  return state.capsule.status;
};

export const getSearchValue = (state: any) => {
  return state.capsule.searchValue;
};

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
// export const incrementIfOdd = (amount) => (dispatch, getState) => {
//   const currentValue = selectCount(getState());
//   if (currentValue % 2 === 1) {
//     dispatch(incrementByAmount(amount));
//   }
// };

export default capsulesSlice.reducer;
